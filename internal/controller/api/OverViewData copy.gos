package api

import (
	"context"
	"encoding/json"
	"fmt"
	"gf_api/internal/db"
	"math"
	"net/http"
	"strings"
	"sync"
	"time"

	_ "github.com/gogf/gf/contrib/drivers/pgsql/v2"
	"github.com/gogf/gf/v2/encoding/gjson"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
	"github.com/gogf/gf/v2/util/gconv"
	"github.com/redis/go-redis/v9"
)

// 台站数据总览 ldc 20250901

// Register 把当前模块的所有路由注册到 group
func Register(group *ghttp.RouterGroup) {
	group.GET("/Basic/OverViewData", GetOverViewData)
	group.GET("/Basic/AllStation", GetAllStaitonInfo)
	group.GET("/Basic/AllStationId", GetAllStationId)
}

// 台站总览的结构体
type OverViewDataRow struct {
	ID                 int64   `json:"id"`
	StationID          string  `json:"station_id"`
	Remarks            string  `json:"remarks"`
	RelationPositionId string  `json:"relation_position_id"`
	SetItemModelId     []g.Map `json:"setitem_model_id"` //查数据库
	OperateModelId     []g.Map `json:"operate_model_id"` //查数据库
	DynamicModelId     []g.Map `json:"dynamic_model_id"` //查数据库
	StaticModelId      []g.Map `json:"static_model_id"`  //查数据库
	ParentNodeId       int64   `json:"parent_node_id"`
	PositionId         string  `json:"position_id"`
	DeviceTypeId       string  `json:"device_type_id"`
	SubSystemId        string  `json:"sub_system_id"`
	NodeName           string  `json:"node_name"`
}

type StationIdResp struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// flattenKeys 用来指定哪些字段需要再去查 Redis
var modelKeyMapping = map[string]string{
	"dynamic_model_id": "svr_dynamic_model",
	"operate_model_id": "svr_operations_model",
	"setitem_model_id": "svr_setitem_model",
	"static_model_id":  "svr_static_model",
}

// 构造台站总览数据接口。
// 参数：stationId，查数据库台站模型表、静态属性表和动态属性表，组成台站模型结构，然后去redis中取字段的值
// 必须先取所有台站信息数据列表得到 stationId, 接口：http://127.0.0.1:8001/api/Basic/AllStationId
func GetOverViewDataOld(r *ghttp.Request) {
	ctx := context.Background()

	// Step 1. 请求 /api/Basic/AllStationId 获取 stationId 列表，只取第一个
	allURL := "http://127.0.0.1:8001/api/Basic/AllStationId" // 建议写到 config.yaml
	resp, err := g.Client().Timeout(5*time.Second).Get(ctx, allURL)
	if err != nil {
		r.Response.WriteJson(g.Map{
			"error": fmt.Sprintf("请求 AllStationId 接口失败: %v", err),
		})
		return
	}
	defer resp.Close()

	if resp.StatusCode != http.StatusOK {
		r.Response.WriteJson(g.Map{
			"error": fmt.Sprintf("AllStationId 接口返回非200: %d", resp.StatusCode),
		})
		return
	}

	// //这里假设接口返回的是数组 [{key:..., value:...}, {...}]
	// var stationList []StationIdResp
	// // 读取响应体
	// body := resp.ReadAll()
	// // 用 gjson.DecodeTo 解析 JSON
	// if err := gjson.DecodeTo(body, &stationList); err != nil {
	// 	r.Response.WriteJson(g.Map{
	// 		"error": fmt.Sprintf("解析 AllStationId 响应失败: %v", err),
	// 	})
	// 	return
	// }
	// if len(stationList) == 0 {
	// 	r.Response.WriteJson(g.Map{
	// 		"error": "未获取到任何 stationId",
	// 	})
	// 	return
	// }
	// // 这里取第一个 stationId
	// stationId := stationList[0].Value
	// if stationId == "" {
	// 	r.Response.WriteJson(g.Map{
	// 		"error": "未获取到 stationId",
	// 	})
	// 	return
	// }

	var stationList []StationIdResp
	body := resp.ReadAll()

	// 适配接口返回结果为数组或单个对象
	if err := gjson.DecodeTo(body, &stationList); err != nil || len(stationList) == 0 {
		// 如果不是数组，再解析成单个对象
		var station StationIdResp
		if err2 := gjson.DecodeTo(body, &station); err2 == nil && station.Value != "" {
			stationList = append(stationList, station)
		}
	}

	if len(stationList) == 0 {
		r.Response.WriteJson(g.Map{
			"error": "未获取到任何 stationId",
		})
		return
	}

	stationId := stationList[0].Value

	db.InitRedis() //初始化Redis

	// Step 2. 查询数据库台站模型表station_node,关联到静态属性表static_model、动态属性表dynamic_model、设置属性表setitem_model和操作属性表operations_model，组成最终的json模型
	//var rows []g.Map
	sql := `
		SELECT node_id, parent_node_id, node_name,dynamic_model_id, static_model_id,setitem_model_id,relation_position_id,position_id
		FROM station_node
		WHERE station_id = $1
		ORDER BY node_id;
		`

	res, err := g.DB().GetAll(ctx, sql, stationId)
	if err != nil {
		fmt.Println("查询台站信息失败:", err)
	}
	// else {
	// 	g.Dump(res) // 打印结果
	// }

	if len(res) == 0 {
		r.Response.Write("{}")
		return
	}

	// 1) 定义总览数据接口的json结构体
	type nodeInfo struct {
		NodeId             int    //节点id
		parent             int    //父节点id
		name               string //节点名字
		dynamic            string //动态节点
		static             string //静态节点
		setitem            string //设置项
		relationPositionID string //关联工位号
		positionID         string //工位号
	}
	//根节点node_id，parent_node_id指向node_id
	nodes := make(map[int]*nodeInfo)   // node_id -> nodeInfo
	childrenMap := make(map[int][]int) // parent_id -> []child_id
	minNodeID := math.MaxInt32         // 找最小的 node_id，当成根

	//遍历数据库结果，填充 nodes 和 childrenMap
	for _, row := range res {
		NodeId := gconv.Int(row["node_id"])
		parent := gconv.Int(row["parent_node_id"])
		name := gconv.String(row["node_name"])
		dynamic := gconv.String(row["dynamic_model_id"])
		static := gconv.String(row["static_model_id"])
		setitem := gconv.String(row["setitem_model_id"])
		relationPositionID := gconv.String(row["relation_position_id"])
		positionID := gconv.String(row["position_id"])

		nodes[NodeId] = &nodeInfo{NodeId: NodeId, parent: parent, name: name, dynamic: dynamic, static: static, setitem: setitem, relationPositionID: relationPositionID, positionID: positionID}
		childrenMap[parent] = append(childrenMap[parent], NodeId)

		if NodeId < minNodeID {
			minNodeID = NodeId
		}
	}

	// 如果没有找到最小节点，就给一个空的根节点，并返回
	if minNodeID == math.MaxInt32 {
		r.Response.Write("{}")
		return
	}

	// 2) 以显式栈做后序遍历（避免递归），并带有环检测
	type frame struct {
		NodeId  int
		visited bool // 标记是否已经处理过子节点。false先处理子节点，true再处理自己
	}

	processed := make(map[int]bool) // 已处理好的节点
	onStack := make(map[int]bool)   //  当前路径上的节点，用于检测环
	result := make(map[int]g.Map)   // 每个 node_id 的子节点树

	stack := []frame{{NodeId: minNodeID, visited: false}}

	// 用于收集检测到的环（仅做日志）
	cycles := make([]int, 0)

	//每次从栈里取一个节点 NodeId，找到对应的 nodeInfo。
	for len(stack) > 0 {
		// pop
		f := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		NodeId := f.NodeId

		nodeInfo, ok := nodes[NodeId]

		// 若parent 指向了一个不存在的节点，即节点不存在，这种情况就生成空 map。
		if !ok {
			result[NodeId] = g.Map{}
			processed[NodeId] = true
			continue
		}

		//当第一次访问时
		if !f.visited {
			if processed[NodeId] {
				// 已构建，跳过
				continue
			}
			if onStack[NodeId] {
				// 如果再次遇到在路径上的节点，说明有环；记录并标记为空，避免死循环
				cycles = append(cycles, NodeId)
				result[NodeId] = g.Map{}
				processed[NodeId] = true
				continue
			}
			// 若还没处理过，就先标记 onStack，再把自己 二次入栈（visited=true），同时把所有子节点先入栈。这样保证 后序遍历（先处理子节点，再处理自己）。
			onStack[NodeId] = true
			stack = append(stack, frame{NodeId: NodeId, visited: true})
			// 子节点入栈
			for _, childID := range childrenMap[NodeId] {
				if !processed[childID] {
					stack = append(stack, frame{NodeId: childID, visited: false})
				}
			}
		} else { //不是第一次访问
			// 遍历子节点，把每个子节点的子树挂到 m 上
			m := g.Map{}
			for _, childID := range childrenMap[NodeId] {
				// child 可能因环或缺失未被 processed，确保 result 有值
				if _, ok := result[childID]; !ok {
					result[childID] = g.Map{}
				}
				// 如果 child 在 nodes 中不存在，则用占位名 "unknown"
				childName := "unknown"
				if n, ok := nodes[childID]; ok {
					childName = n.name
				}
				m[childName] = result[childID]
			}

			// 处理redis动态属性：再取 dynamic_model_id 对应的 redis 值
			// 查找对应的 dynamic_model_id，动态属性。
			// staton_node表中有工位号position_id和关联工位号relation_position_id，在dynamic_model_id查出来的结果中，取key作为节点字段属性放到父节点下，而值是根据下面的规则取值：
			// 1.每个节点属性下面都有属性名panro和关联属性名relation_parno；
			// 2.设变量Num:当关联工位号relation_position_id和关联属性relation_parno都有值，则使用Num=relation_position_id；否则使用Num=position_id。
			// 3.当is_enable=1时，表示有设备，则Num=position_id
			// 4.去redis中查key=svr_DATA_Num的值，作为节点属性值。
			if nodeInfo.dynamic != "" {
				// 获取指定 key=svr_dynamic_model 下的所有字段和值
				allDynCmd := db.Redis.HGetAll(ctx, "svr_dynamic_model")
				allDyn, err := allDynCmd.Result()
				if err != nil {
					fmt.Println(ctx, "获取 redis svr_dynamic_model 失败:", err)
				} else {
					// 找到当前 dynamic_model_id 对应的值
					dynVal, ok := allDyn[nodeInfo.dynamic]
					if ok && dynVal != "" {
						// 解析成 map[string]any
						var dyn map[string]any
						if err := json.Unmarshal([]byte(dynVal), &dyn); err != nil {
							// 解析失败 → 挂原始字符串
							fmt.Println("dynamic json unmarshal failed:", nodeInfo.dynamic, "err:", err)
							m[nodeInfo.name] = dynVal
						} else {
							// 遍历 dynamic_model_id 下的每个属性（key:属性名，value:属性值）
							for attrKey, attrVal := range dyn {
								if attrObj, ok := attrVal.(map[string]any); ok {
									// 提取 para_name、relation_parno、is_enable
									//parno, _ := attrObj["parno"].(string)
									relationParno, _ := attrObj["relation_parno"].(string)
									isEnable := "0"                        //默认
									if v, ok := attrObj["is_enable"]; ok { //is_enable这个字段不一定在redis中存在
										switch vv := v.(type) {
										case string:
											isEnable = vv
										case float64: // JSON 里数字默认是 float64
											if vv == 1 {
												isEnable = "1"
											}
										}
									}
									// fmt.Println("parno:", parno)
									// fmt.Println("relation_parno:", relationParno)
									// fmt.Println("is_enable:", isEnable)

									// =============== 规则逻辑开始 ===============
									// 设变量 Num = position_id，默认情况
									num := nodeInfo.positionID

									// 如果 relation_position_id 和 relation_parno 都有值 → Num = relation_position_id
									if nodeInfo.relationPositionID != "" && relationParno != "" {
										num = nodeInfo.relationPositionID
									}

									// 如果 is_enable = "1" → 强制 Num = position_id
									if isEnable == "1" {
										num = nodeInfo.positionID
									}
									// =============== 规则逻辑结束 ===============

									// 拼接 redis的key = svr_DATA_Num
									redisKey := fmt.Sprintf("svr_DATA_%s", num)
									valCmd := db.Redis.Get(ctx, redisKey)
									val, err := valCmd.Result()
									if err != nil {
										//fmt.Println("获取 redis key 失败:", redisKey, "err:", err)
										// 兜底：把 para_value 挂上去
										pv := ""
										if v, ok := attrObj["para_value"]; ok {
											switch vv := v.(type) {
											case string:
												pv = vv
											case float64: // 如果 JSON 里是数字
												pv = fmt.Sprintf("%v", vv)
											default:
												// 其他类型，转成字符串
												pv = fmt.Sprintf("%v", vv)
											}
										}
										m[attrKey] = pv
									} else {
										// 正常挂 redis 里的值
										m[attrKey] = val
									}

									// 调试输出
									// fmt.Printf("节点:%s 属性:%s Num:%s redisKey:%s => %v\n",
									// 	nodeInfo.name, paraName, num, redisKey, m[attrKey])
								}
							}
						}
					} else {
						fmt.Println("查询不到对应的 dynamic_model_id:", nodeInfo.dynamic)
					}
				}
			}

			// 处理静态属性
			if nodeInfo.static != "" {
				allSticCmd := db.Redis.HGetAll(ctx, "svr_static_model")
				allStic, _ := allSticCmd.Result()
				sticVal, ok := allStic[nodeInfo.static] //去结果中查key的值
				if ok && sticVal != "" {
					var stic map[string]any
					if err := json.Unmarshal([]byte(sticVal), &stic); err != nil {
						// 解析失败 → 只打日志，不污染结果
						fmt.Println("static json unmarshal failed:", nodeInfo.static, "err:", err)
					} else {
						for attrKey, attrVal := range stic {
							if attrObj, ok := attrVal.(map[string]any); ok {
								// 安全取 para_value
								pv := getStringAttr(attrObj, "para_value", "")
								m[attrKey] = pv
							} else {
								// 如果不是 map，直接转成字符串
								m[attrKey] = fmt.Sprintf("%v", attrVal)
							}
						}
					}
				} else {
					fmt.Println("查询不到对应的 static_model_id:", nodeInfo.static)
				}
			}

			//处理设置项属性，规则与动态属性表一致
			// staton_node表中有工位号position_id和关联工位号relation_position_id，在svr_setitem_model查出来的结果中，取key作为节点字段属性放到父节点下，而值是根据下面的规则取值：
			// 1.每个节点属性下面都有属性名panro和关联属性名relation_parno；
			// 2.设变量Num:当关联工位号relation_position_id和关联属性relation_parno都有值，则使用Num=relation_position_id；否则使用Num=position_id。
			// 3.当is_enable=1时，表示有设备，则Num=position_id
			// 4.去redis中查key=svr_DATA_Num的值，作为节点属性值。
			if nodeInfo.setitem != "" {
				// 获取指定 key=svr_setitem_model 下的所有字段和值
				allSetCmd := db.Redis.HGetAll(ctx, "svr_setitem_model")
				allSet, _ := allSetCmd.Result()
				if err != nil {
					fmt.Println(ctx, "获取 redis svr_setitem_model 失败:", err)
				} else {
					// 找到当前 setitem_model_id 对应的值
					setVal, ok := allSet[nodeInfo.setitem]
					if ok && setVal != "" {
						// 解析成 map[string]any
						var set map[string]any
						if err := json.Unmarshal([]byte(setVal), &set); err != nil {
							// 解析失败 → 挂原始字符串
							fmt.Println("setitem json unmarshal failed:", nodeInfo.setitem, "err:", err)
							m[nodeInfo.name] = setVal
						} else {
							// 遍历 setitem_model_id 下的每个属性（key:属性名，value:属性值）
							for attrKey, attrVal := range set {
								if attrObj, ok := attrVal.(map[string]any); ok {
									// 提取 para_name、relation_parno、is_enable
									relationParno, _ := attrObj["relation_parno"].(string)
									isEnable := "0"                        //默认
									if v, ok := attrObj["is_enable"]; ok { //is_enable这个字段不一定在redis中存在
										switch vv := v.(type) {
										case string:
											isEnable = vv
										case float64: // JSON 里数字默认是 float64
											if vv == 1 {
												isEnable = "1"
											}
										}
									}
									// fmt.Println("parno:", parno)
									// fmt.Println("relation_parno:", relationParno)
									// fmt.Println("is_enable:", isEnable)

									// =============== 规则逻辑开始 ===============
									// 设变量 Num = position_id，默认情况
									num := nodeInfo.positionID

									// 如果 relation_position_id 和 relation_parno 都有值 → Num = relation_position_id
									if nodeInfo.relationPositionID != "" && relationParno != "" {
										num = nodeInfo.relationPositionID
									}

									// 如果 is_enable = "1" → 强制 Num = position_id
									if isEnable == "1" {
										num = nodeInfo.positionID
									}
									// =============== 规则逻辑结束 ===============

									// 拼接 redis的key = svr_DATA_Num
									redisKey := fmt.Sprintf("svr_DATA_%s", num)
									valCmd := db.Redis.Get(ctx, redisKey)
									val, err := valCmd.Result()
									keyLower := strings.ToLower(attrKey) // key 转小写
									if err != nil {
										//fmt.Println("获取 redis key 失败:", redisKey, "err:", err)
										// 兜底：把 para_value 挂上去
										pv := ""
										if v, ok := attrObj["para_value"]; ok {
											switch vv := v.(type) {
											case string:
												pv = strings.ToLower(vv)
											case float64: // 如果 JSON 里是数字
												pv = fmt.Sprintf("%v", vv)
											default:
												// 其他类型，转成字符串
												pv = fmt.Sprintf("%v", vv)
											}
										}
										m[keyLower] = strings.ToLower(pv) // 挂到结果前再转小写
									} else {
										// 正常挂 redis 里的值
										// 如果不是 map，直接转成字符串并转小写
										m[keyLower] = strings.ToLower(fmt.Sprintf("%v", val))
									}

									// 调试输出
									// fmt.Printf("节点:%s 属性:%s Num:%s redisKey:%s => %v\n",
									// 	nodeInfo.name, paraName, num, redisKey, m[attrKey])
								}
							}
						}
					} else {
						fmt.Println("查询不到对应的 setitem_model_id:", nodeInfo.setitem)
					}
				}
			}

			//当前节点处理完成，保存结果并解除 onStack
			result[NodeId] = m
			processed[NodeId] = true
			onStack[NodeId] = false
		}
	}

	// 3) 最终结果：以 minNodeID 作为根（“node_id 最小为第一节点”）
	finalJSON := result[minNodeID]

	// 4) 如果检测到环，记录日志（可选：也可以把这些信息返回给前端）
	if len(cycles) > 0 {
		fmt.Println(ctx, "检测到环形引用（已自动忽略），示例节点id：", cycles)
	}

	// 5) 转 JSON 并返回
	jsonStr := gjson.New(finalJSON).MustToJsonString()
	//fmt.Println(jsonStr)
	r.Response.Write(jsonStr)
}

func GetStationIdInfo(r *ghttp.Request) {
	ctx := context.Background()

	// 请求 /api/Basic/AllStationId 获取 stationId 列表
	allURL := "http://127.0.0.1:8001/api/Basic/AllStationId" // 建议写到 config.yaml
	resp, err := g.Client().Timeout(5*time.Second).Get(ctx, allURL)
	if err != nil {
		r.Response.WriteJson(g.Map{
			"error": fmt.Sprintf("请求 AllStationId 接口失败: %v", err),
		})
		return
	}
	defer resp.Close()

	if resp.StatusCode != http.StatusOK {
		r.Response.WriteJson(g.Map{
			"error": fmt.Sprintf("AllStationId 接口返回非200: %d", resp.StatusCode),
		})
		return
	}

	var stationList []StationIdResp
	body := resp.ReadAll()

	// 适配接口返回结果为数组或单个对象
	if err := gjson.DecodeTo(body, &stationList); err != nil || len(stationList) == 0 {
		// 如果不是数组，再解析成单个对象
		var station StationIdResp
		if err2 := gjson.DecodeTo(body, &station); err2 == nil && station.Value != "" {
			stationList = append(stationList, station)
		}
	}

	if len(stationList) == 0 {
		r.Response.WriteJson(g.Map{
			"error": "未获取到任何 stationId",
		})
		return
	}
	//stationId := stationList[0].Value //只取第一个
}

// 台站总览数据接口 ldc 20251014
func GetOverViewData(r *ghttp.Request) {
	ctx := context.Background()
	start := time.Now()

	stationId := r.Get("stationId").String()
	if stationId == "" {
		r.Response.WriteJson(g.Map{"error": "缺少参数 stationId"})
		return
	}

	// 初始化 Redis 连接（仅一次）
	db.InitRedis()

	// 加载模型缓存（只读一次 Redis）
	cache, err := LoadModelCache(ctx)
	if err != nil {
		r.Response.WriteJson(g.Map{"error": fmt.Sprintf("加载模型缓存失败: %v", err)})
		return
	}

	logStep := func(label string, t0 time.Time) {
		fmt.Printf("阶段 %s 耗时: %v ms\n", label, time.Since(t0).Milliseconds())
	}

	// 1.读取 Basic 和 Idx（并行）
	var (
		basicStr, idxStr string
		basicErr, idxErr error
	)
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		defer wg.Done()
		t0 := time.Now()
		basicStr, basicErr = db.Redis.HGet(ctx, "svr_stationNodeModelBasic", stationId).Result()
		logStep("1 Basic读取", t0)
	}()

	go func() {
		defer wg.Done()
		t0 := time.Now()
		idxStr, idxErr = db.Redis.HGet(ctx, "svr_stationNodeModelIdx", stationId).Result()
		logStep("2 Idx读取", t0)
	}()

	wg.Wait()

	if basicErr != nil {
		r.Response.WriteJson(g.Map{"error": fmt.Sprintf("读取 svr_stationNodeModelBasic 出错: %v", basicErr)})
		return
	}
	if idxErr != nil {
		r.Response.WriteJson(g.Map{"error": fmt.Sprintf("读取 svr_stationNodeModelIdx 出错: %v", idxErr)})
		return
	}

	// 2.解析 JSON（并行）
	var basic, idx map[string]interface{}
	wg.Add(2)

	go func() {
		defer wg.Done()
		t0 := time.Now()
		_ = json.Unmarshal([]byte(basicStr), &basic)
		logStep("3 Basic解析", t0)
	}()
	go func() {
		defer wg.Done()
		t0 := time.Now()
		_ = json.Unmarshal([]byte(idxStr), &idx)
		logStep("4 Idx解析", t0)
	}()

	wg.Wait()

	// 3.调用缓存版 mergeRecursive（避免 Redis 访问）
	t0 := time.Now()
	mergeRecursive(ctx, basic, idx, cache)
	logStep("5 mergeRecursive", t0)

	// 判断 basic 是否为空
	result := "false"
	if len(basic) > 0 {
		// 如果 basic 中有 "Content" 或其他关键字段，也可以判断 basic["Content"] 是否非空
		if content, ok := basic["Content"]; ok {
			switch c := content.(type) {
			case map[string]interface{}:
				if len(c) > 0 {
					result = "true"
				}
			case string:
				if c != "" {
					result = "true"
				}
			default:
				result = "true"
			}
		} else {
			// 没有 "Content" 字段，只要 basic 非空也认为成功
			result = "true"
		}
	}

	// 4.统一输出结果
	durationMs := time.Since(start).Milliseconds()
	r.Response.WriteJson(g.Map{
		"stationId":   stationId,
		"MachineName": "",     //服务节点名称，留空
		"Result":      result, // 是否成功
		"timestamp":   time.Now().Format("2006-01-02 15:04:05"),
		"time":        durationMs, //生成此接口所需的毫秒级时间
		"Message":     "",
		"Content":     basic,
	})
}

// 预加载模型，动态、静态和设置项 20251014 ldc
type ModelCache struct {
	Dynamic map[string]map[string]map[string]interface{}
	Static  map[string]map[string]interface{}
	SetItem map[string]map[string]map[string]interface{}
}

// 加载redis模型缓存,以便减少访问redis的次数 20251014 ldc
func LoadModelCache(ctx context.Context) (*ModelCache, error) {
	cache := &ModelCache{
		Dynamic: make(map[string]map[string]map[string]interface{}),
		Static:  make(map[string]map[string]interface{}),
		SetItem: make(map[string]map[string]map[string]interface{}),
	}

	// 动态模型
	if all, err := db.Redis.HGetAll(ctx, "svr_dynamic_model").Result(); err == nil {
		for id, jsonStr := range all {
			var obj map[string]map[string]interface{}
			if err := json.Unmarshal([]byte(jsonStr), &obj); err == nil {
				cache.Dynamic[id] = obj
			}
		}
	}

	// 静态模型
	if all, err := db.Redis.HGetAll(ctx, "svr_static_model").Result(); err == nil {
		for id, jsonStr := range all {
			var obj map[string]interface{}
			if err := json.Unmarshal([]byte(jsonStr), &obj); err == nil {
				cache.Static[id] = obj
			}
		}
	}

	// 设置模型
	if all, err := db.Redis.HGetAll(ctx, "svr_setitem_model").Result(); err == nil {
		for id, jsonStr := range all {
			var obj map[string]map[string]interface{}
			if err := json.Unmarshal([]byte(jsonStr), &obj); err == nil {
				cache.SetItem[id] = obj
			}
		}
	}

	return cache, nil
}

// mergeRecursive 合并数据总览的基本属性Basic 和 数据总览的详细属性Idx。这个函数是从缓存中取，而不是每次都去查redis，速度快点。20251014 ldc
func mergeRecursive(ctx context.Context, basic, idx map[string]interface{}, cache *ModelCache) {
	if id, ok := idx["dynamic_model_id"].(string); ok && id != "" {
		processDynamicModelCached(ctx, idx, id, cache)
		basic["dynamic_model_id"] = id
	}

	if id, ok := idx["static_model_id"].(string); ok && id != "" {
		processStaticModelCached(ctx, idx, id, cache)
		basic["static_model_id"] = id
	}

	if id, ok := idx["setitem_model_id"].(string); ok && id != "" {
		processSetitemModelCached(ctx, idx, id, cache)
		basic["setitem_model_id"] = id
	}

	for k, v := range idx {
		if k == "dynamic_model_id" || k == "static_model_id" || k == "setitem_model_id" {
			continue
		}
		if k == "rConfig" {
			if sub, ok := v.(map[string]interface{}); ok {
				mergeRecursive(ctx, basic, sub, cache)
			}
			continue
		}

		switch sub := v.(type) {
		case map[string]interface{}:
			child, _ := basic[k].(map[string]interface{})
			if child == nil {
				child = make(map[string]interface{})
				basic[k] = child
			}
			mergeRecursive(ctx, child, sub, cache)
		default:
			basic[k] = v
		}
	}
}

// 从缓存中取动态属性  20251014 ldc
/***
查dynamic_model_id的值的时候，DTVSystemSwitcher_1属性中有工位号positionId和关联工位号rpositionId，
在dynamic_model_id查出来的结果中，取key作为节点字段属性放到父节点下，而值是根据下面的规则取值：
1.每个节点属性下面都有属性名panro和关联属性名relation_parno；
2.设变量Num：当关联工位号rpositionId和关联属性relation_parno都有值，则Num=rpositionId；否则Num=positionId。
3.当is_enable=1时，表示有设备，则Num=positionId；
4.去redis中查key=svr_DATA_Num的值，作为节点属性的值。
***/
func processDynamicModelCached(ctx context.Context, node map[string]interface{}, modelID string, cache *ModelCache) {
	positionId, _ := node["positionId"].(string)
	rPositionId, _ := node["rPositionId"].(string)

	// 从缓存中取出动态模型定义
	modelDef, ok := cache.Dynamic[modelID]
	if !ok {
		return
	}

	for attrName, attrDef := range modelDef {
		attrName = strings.ToLower(attrName)

		relationParno, _ := attrDef["relation_parno"].(string)
		isEnable, _ := attrDef["is_enable"].(float64)

		Num := positionId
		if rPositionId != "" && relationParno != "" {
			Num = rPositionId
		}
		if isEnable == 1 {
			Num = positionId
		}

		// 从 Redis 获取数据值（或从另外一个缓存层中取）
		dataKey := fmt.Sprintf("svr_DATA_%s", Num)
		dataVal, err := db.Redis.HGet(ctx, dataKey, attrName).Result()
		if err != nil {
			continue
		}
		node[attrName] = dataVal
	}
}

// 从缓存中取静态属性 20251014 ldc
func processStaticModelCached(ctx context.Context, node map[string]interface{}, modelID string, cache *ModelCache) {
	positionId, _ := node["positionId"].(string)
	rPositionId, _ := node["rPositionId"].(string)

	// 从缓存中获取静态模型定义
	modelDef, ok := cache.Static[modelID]
	if !ok {
		return
	}

	for attrName, attrDef := range modelDef {
		attrName = strings.ToLower(attrName)

		// attrDef 可能是 map[string]interface{}
		if attrMap, ok := attrDef.(map[string]interface{}); ok {
			// 取模型定义的 para_value
			if paraValue, ok := attrMap["para_value"]; ok {
				node[attrName] = paraValue
				continue
			}

			// 取动态关联参数
			if relationParno, ok := attrMap["relation_parno"].(string); ok {
				isEnable, _ := attrMap["is_enable"].(float64)

				Num := positionId
				if rPositionId != "" && relationParno != "" {
					Num = rPositionId
				}
				if isEnable == 1 {
					Num = positionId
				}

				dataKey := fmt.Sprintf("svr_DATA_%s", Num)
				dataVal, err := db.Redis.HGet(ctx, dataKey, attrName).Result()
				if err == nil {
					node[attrName] = dataVal
				}
			}
		} else {
			// 如果是普通值，直接赋
			node[attrName] = attrDef
		}
	}
}

// 从缓存中取设置项属性 20251014 ldc
func processSetitemModelCached(ctx context.Context, node map[string]interface{}, modelID string, cache *ModelCache) {
	positionId, _ := node["positionId"].(string)
	rPositionId, _ := node["rPositionId"].(string)

	modelDef, ok := cache.SetItem[modelID]
	if !ok {
		return
	}

	for attrName, attrDef := range modelDef {
		attrName = strings.ToLower(attrName)

		relationParno, _ := attrDef["relation_parno"].(string)
		isEnable, _ := attrDef["is_enable"].(float64)

		// 确定使用哪个 Num
		Num := positionId
		if rPositionId != "" && relationParno != "" {
			Num = rPositionId
		}
		if isEnable == 1 {
			Num = positionId
		}

		// 从 Redis 中获取 svr_DATA_<Num>
		dataKey := fmt.Sprintf("svr_DATA_%s", Num)
		dataVal, err := db.Redis.HGet(ctx, dataKey, attrName).Result()
		if err != nil {
			continue
		}

		node[attrName] = dataVal
	}
}

// getStringAttr 安全地从 map[string]any 里取 string 值
func getStringAttr(obj map[string]any, key, def string) string {
	if v, ok := obj[key]; ok {
		switch vv := v.(type) {
		case string:
			return vv
		case float64: // JSON number 默认会被解成 float64
			return fmt.Sprintf("%v", vv)
		default:
			return fmt.Sprintf("%v", vv)
		}
	}
	return def
}

// 获取所有台站信息接口
func GetAllStaitonInfo(r *ghttp.Request) {
	ctx := context.Background()
	key := "svr_stations"

	val, err := db.Redis.Get(ctx, key).Result()
	if err != nil {
		if err == redis.Nil { // 注意这里redis.Nil,它是 github.com/redis/go-redis/v9 包里定义
			// key 不存在
			r.Response.WriteJson(g.Map{
				"error": fmt.Sprintf("Redis key '%s' 不存在", key),
			})
			return
		}
		// 其他错误
		r.Response.WriteJson(g.Map{
			"error": err.Error(),
		})
		return
	}

	// 成功获取值
	r.Response.WriteJson(g.Map{
		"key":   key,
		"value": val,
	})
}

// 获取所有台站Id接口
func GetAllStationId(r *ghttp.Request) {
	ctx := context.Background()
	key := "svr_station_id"

	val, err := db.Redis.Get(ctx, key).Result()
	if err != nil {
		if err == redis.Nil { // 注意这里redis.Nil,它是 github.com/redis/go-redis/v9 包里定义
			// key 不存在
			r.Response.WriteJson(g.Map{
				"error": fmt.Sprintf("Redis key '%s' 不存在", key),
			})
			return
		}
		// 其他错误
		r.Response.WriteJson(g.Map{
			"error": err.Error(),
		})
		return
	}

	// 成功获取值
	r.Response.WriteJson(g.Map{
		"key":   key,
		"value": val,
	})
}
